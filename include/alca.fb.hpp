// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALCA_SENSOR_H_
#define FLATBUFFERS_GENERATED_ALCA_SENSOR_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Sensor {

struct FileEvent;
struct FileEventBuilder;

struct NetworkEvent;
struct NetworkEventBuilder;

struct ProcessEvent;
struct ProcessEventBuilder;

struct RegistryEvent;
struct RegistryEventBuilder;

enum FileAction : int8_t {
  FileAction_FileCreate = 0,
  FileAction_FileRename = 1,
  FileAction_FileDelete = 2,
  FileAction_FileModify = 3,
  FileAction_MIN = FileAction_FileCreate,
  FileAction_MAX = FileAction_FileModify
};

inline const FileAction (&EnumValuesFileAction())[4] {
  static const FileAction values[] = {
    FileAction_FileCreate,
    FileAction_FileRename,
    FileAction_FileDelete,
    FileAction_FileModify
  };
  return values;
}

inline const char * const *EnumNamesFileAction() {
  static const char * const names[5] = {
    "FileCreate",
    "FileRename",
    "FileDelete",
    "FileModify",
    nullptr
  };
  return names;
}

inline const char *EnumNameFileAction(FileAction e) {
  if (::flatbuffers::IsOutRange(e, FileAction_FileCreate, FileAction_FileModify)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFileAction()[index];
}

enum NetworkAction : int8_t {
  NetworkAction_NetAccept = 0,
  NetworkAction_NetConnect = 1,
  NetworkAction_NetDisconnect = 2,
  NetworkAction_NetSend = 3,
  NetworkAction_NetReceive = 4,
  NetworkAction_MIN = NetworkAction_NetAccept,
  NetworkAction_MAX = NetworkAction_NetReceive
};

inline const NetworkAction (&EnumValuesNetworkAction())[5] {
  static const NetworkAction values[] = {
    NetworkAction_NetAccept,
    NetworkAction_NetConnect,
    NetworkAction_NetDisconnect,
    NetworkAction_NetSend,
    NetworkAction_NetReceive
  };
  return values;
}

inline const char * const *EnumNamesNetworkAction() {
  static const char * const names[6] = {
    "NetAccept",
    "NetConnect",
    "NetDisconnect",
    "NetSend",
    "NetReceive",
    nullptr
  };
  return names;
}

inline const char *EnumNameNetworkAction(NetworkAction e) {
  if (::flatbuffers::IsOutRange(e, NetworkAction_NetAccept, NetworkAction_NetReceive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNetworkAction()[index];
}

enum ProcessAction : int8_t {
  ProcessAction_ProcessStart = 0,
  ProcessAction_ProcessEnd = 1,
  ProcessAction_CreateRemoteThread = 2,
  ProcessAction_CreateLocalThread = 3,
  ProcessAction_TerminateLocalThread = 4,
  ProcessAction_TerminateRemoteThread = 5,
  ProcessAction_ImageLoad = 6,
  ProcessAction_ImageUnload = 7,
  ProcessAction_AllocLocal = 8,
  ProcessAction_AllocRemote = 9,
  ProcessAction_MIN = ProcessAction_ProcessStart,
  ProcessAction_MAX = ProcessAction_AllocRemote
};

inline const ProcessAction (&EnumValuesProcessAction())[10] {
  static const ProcessAction values[] = {
    ProcessAction_ProcessStart,
    ProcessAction_ProcessEnd,
    ProcessAction_CreateRemoteThread,
    ProcessAction_CreateLocalThread,
    ProcessAction_TerminateLocalThread,
    ProcessAction_TerminateRemoteThread,
    ProcessAction_ImageLoad,
    ProcessAction_ImageUnload,
    ProcessAction_AllocLocal,
    ProcessAction_AllocRemote
  };
  return values;
}

inline const char * const *EnumNamesProcessAction() {
  static const char * const names[11] = {
    "ProcessStart",
    "ProcessEnd",
    "CreateRemoteThread",
    "CreateLocalThread",
    "TerminateLocalThread",
    "TerminateRemoteThread",
    "ImageLoad",
    "ImageUnload",
    "AllocLocal",
    "AllocRemote",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessAction(ProcessAction e) {
  if (::flatbuffers::IsOutRange(e, ProcessAction_ProcessStart, ProcessAction_AllocRemote)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProcessAction()[index];
}

enum RegistryAction : int8_t {
  RegistryAction_RegOpenKey = 0,
  RegistryAction_RegCreateKey = 1,
  RegistryAction_RegSetValue = 2,
  RegistryAction_RegDeleteKey = 3,
  RegistryAction_RegDeleteValue = 4,
  RegistryAction_MIN = RegistryAction_RegOpenKey,
  RegistryAction_MAX = RegistryAction_RegDeleteValue
};

inline const RegistryAction (&EnumValuesRegistryAction())[5] {
  static const RegistryAction values[] = {
    RegistryAction_RegOpenKey,
    RegistryAction_RegCreateKey,
    RegistryAction_RegSetValue,
    RegistryAction_RegDeleteKey,
    RegistryAction_RegDeleteValue
  };
  return values;
}

inline const char * const *EnumNamesRegistryAction() {
  static const char * const names[6] = {
    "RegOpenKey",
    "RegCreateKey",
    "RegSetValue",
    "RegDeleteKey",
    "RegDeleteValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameRegistryAction(RegistryAction e) {
  if (::flatbuffers::IsOutRange(e, RegistryAction_RegOpenKey, RegistryAction_RegDeleteValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRegistryAction()[index];
}

struct FileEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_NAME = 6,
    VT_PATH = 8,
    VT_DIRECTORY = 10,
    VT_EXTENSION = 12,
    VT_NEW_NAME = 14,
    VT_IS_DIRECTORY = 16
  };
  Sensor::FileAction action() const {
    return static_cast<Sensor::FileAction>(GetField<int8_t>(VT_ACTION, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  const ::flatbuffers::String *directory() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTORY);
  }
  const ::flatbuffers::String *extension() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTENSION);
  }
  const ::flatbuffers::String *new_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEW_NAME);
  }
  bool is_directory() const {
    return GetField<uint8_t>(VT_IS_DIRECTORY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTION, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_DIRECTORY) &&
           verifier.VerifyString(directory()) &&
           VerifyOffset(verifier, VT_EXTENSION) &&
           verifier.VerifyString(extension()) &&
           VerifyOffset(verifier, VT_NEW_NAME) &&
           verifier.VerifyString(new_name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_DIRECTORY, 1) &&
           verifier.EndTable();
  }
};

struct FileEventBuilder {
  typedef FileEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action(Sensor::FileAction action) {
    fbb_.AddElement<int8_t>(FileEvent::VT_ACTION, static_cast<int8_t>(action), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FileEvent::VT_NAME, name);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(FileEvent::VT_PATH, path);
  }
  void add_directory(::flatbuffers::Offset<::flatbuffers::String> directory) {
    fbb_.AddOffset(FileEvent::VT_DIRECTORY, directory);
  }
  void add_extension(::flatbuffers::Offset<::flatbuffers::String> extension) {
    fbb_.AddOffset(FileEvent::VT_EXTENSION, extension);
  }
  void add_new_name(::flatbuffers::Offset<::flatbuffers::String> new_name) {
    fbb_.AddOffset(FileEvent::VT_NEW_NAME, new_name);
  }
  void add_is_directory(bool is_directory) {
    fbb_.AddElement<uint8_t>(FileEvent::VT_IS_DIRECTORY, static_cast<uint8_t>(is_directory), 0);
  }
  explicit FileEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FileEvent> CreateFileEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::FileAction action = Sensor::FileAction_FileCreate,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> directory = 0,
    ::flatbuffers::Offset<::flatbuffers::String> extension = 0,
    ::flatbuffers::Offset<::flatbuffers::String> new_name = 0,
    bool is_directory = false) {
  FileEventBuilder builder_(_fbb);
  builder_.add_new_name(new_name);
  builder_.add_extension(extension);
  builder_.add_directory(directory);
  builder_.add_path(path);
  builder_.add_name(name);
  builder_.add_is_directory(is_directory);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileEvent> CreateFileEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::FileAction action = Sensor::FileAction_FileCreate,
    const char *name = nullptr,
    const char *path = nullptr,
    const char *directory = nullptr,
    const char *extension = nullptr,
    const char *new_name = nullptr,
    bool is_directory = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  auto directory__ = directory ? _fbb.CreateString(directory) : 0;
  auto extension__ = extension ? _fbb.CreateString(extension) : 0;
  auto new_name__ = new_name ? _fbb.CreateString(new_name) : 0;
  return Sensor::CreateFileEvent(
      _fbb,
      action,
      name__,
      path__,
      directory__,
      extension__,
      new_name__,
      is_directory);
}

struct NetworkEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_TCP = 6,
    VT_UDP = 8,
    VT_IPV6 = 10,
    VT_LOCAL_ADDR = 12,
    VT_LOCAL_PORT = 14,
    VT_REMOTE_ADDR = 16,
    VT_REMOTE_PORT = 18,
    VT_PACKET_SIZE = 20
  };
  Sensor::NetworkAction action() const {
    return static_cast<Sensor::NetworkAction>(GetField<int8_t>(VT_ACTION, 0));
  }
  bool tcp() const {
    return GetField<uint8_t>(VT_TCP, 0) != 0;
  }
  bool udp() const {
    return GetField<uint8_t>(VT_UDP, 0) != 0;
  }
  bool ipv6() const {
    return GetField<uint8_t>(VT_IPV6, 0) != 0;
  }
  const ::flatbuffers::String *local_addr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCAL_ADDR);
  }
  int16_t local_port() const {
    return GetField<int16_t>(VT_LOCAL_PORT, 0);
  }
  const ::flatbuffers::String *remote_addr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMOTE_ADDR);
  }
  int16_t remote_port() const {
    return GetField<int16_t>(VT_REMOTE_PORT, 0);
  }
  int32_t packet_size() const {
    return GetField<int32_t>(VT_PACKET_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TCP, 1) &&
           VerifyField<uint8_t>(verifier, VT_UDP, 1) &&
           VerifyField<uint8_t>(verifier, VT_IPV6, 1) &&
           VerifyOffset(verifier, VT_LOCAL_ADDR) &&
           verifier.VerifyString(local_addr()) &&
           VerifyField<int16_t>(verifier, VT_LOCAL_PORT, 2) &&
           VerifyOffset(verifier, VT_REMOTE_ADDR) &&
           verifier.VerifyString(remote_addr()) &&
           VerifyField<int16_t>(verifier, VT_REMOTE_PORT, 2) &&
           VerifyField<int32_t>(verifier, VT_PACKET_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct NetworkEventBuilder {
  typedef NetworkEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action(Sensor::NetworkAction action) {
    fbb_.AddElement<int8_t>(NetworkEvent::VT_ACTION, static_cast<int8_t>(action), 0);
  }
  void add_tcp(bool tcp) {
    fbb_.AddElement<uint8_t>(NetworkEvent::VT_TCP, static_cast<uint8_t>(tcp), 0);
  }
  void add_udp(bool udp) {
    fbb_.AddElement<uint8_t>(NetworkEvent::VT_UDP, static_cast<uint8_t>(udp), 0);
  }
  void add_ipv6(bool ipv6) {
    fbb_.AddElement<uint8_t>(NetworkEvent::VT_IPV6, static_cast<uint8_t>(ipv6), 0);
  }
  void add_local_addr(::flatbuffers::Offset<::flatbuffers::String> local_addr) {
    fbb_.AddOffset(NetworkEvent::VT_LOCAL_ADDR, local_addr);
  }
  void add_local_port(int16_t local_port) {
    fbb_.AddElement<int16_t>(NetworkEvent::VT_LOCAL_PORT, local_port, 0);
  }
  void add_remote_addr(::flatbuffers::Offset<::flatbuffers::String> remote_addr) {
    fbb_.AddOffset(NetworkEvent::VT_REMOTE_ADDR, remote_addr);
  }
  void add_remote_port(int16_t remote_port) {
    fbb_.AddElement<int16_t>(NetworkEvent::VT_REMOTE_PORT, remote_port, 0);
  }
  void add_packet_size(int32_t packet_size) {
    fbb_.AddElement<int32_t>(NetworkEvent::VT_PACKET_SIZE, packet_size, 0);
  }
  explicit NetworkEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetworkEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetworkEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetworkEvent> CreateNetworkEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::NetworkAction action = Sensor::NetworkAction_NetAccept,
    bool tcp = false,
    bool udp = false,
    bool ipv6 = false,
    ::flatbuffers::Offset<::flatbuffers::String> local_addr = 0,
    int16_t local_port = 0,
    ::flatbuffers::Offset<::flatbuffers::String> remote_addr = 0,
    int16_t remote_port = 0,
    int32_t packet_size = 0) {
  NetworkEventBuilder builder_(_fbb);
  builder_.add_packet_size(packet_size);
  builder_.add_remote_addr(remote_addr);
  builder_.add_local_addr(local_addr);
  builder_.add_remote_port(remote_port);
  builder_.add_local_port(local_port);
  builder_.add_ipv6(ipv6);
  builder_.add_udp(udp);
  builder_.add_tcp(tcp);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetworkEvent> CreateNetworkEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::NetworkAction action = Sensor::NetworkAction_NetAccept,
    bool tcp = false,
    bool udp = false,
    bool ipv6 = false,
    const char *local_addr = nullptr,
    int16_t local_port = 0,
    const char *remote_addr = nullptr,
    int16_t remote_port = 0,
    int32_t packet_size = 0) {
  auto local_addr__ = local_addr ? _fbb.CreateString(local_addr) : 0;
  auto remote_addr__ = remote_addr ? _fbb.CreateString(remote_addr) : 0;
  return Sensor::CreateNetworkEvent(
      _fbb,
      action,
      tcp,
      udp,
      ipv6,
      local_addr__,
      local_port,
      remote_addr__,
      remote_port,
      packet_size);
}

struct ProcessEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_PID = 6,
    VT_NAME = 8,
    VT_SELF_PID = 10,
    VT_COMMAND_LINE = 12,
    VT_IMAGE_NAME = 14
  };
  Sensor::ProcessAction action() const {
    return static_cast<Sensor::ProcessAction>(GetField<int8_t>(VT_ACTION, 0));
  }
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t self_pid() const {
    return GetField<int32_t>(VT_SELF_PID, 0);
  }
  const ::flatbuffers::String *command_line() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND_LINE);
  }
  const ::flatbuffers::String *image_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTION, 1) &&
           VerifyField<int32_t>(verifier, VT_PID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_SELF_PID, 4) &&
           VerifyOffset(verifier, VT_COMMAND_LINE) &&
           verifier.VerifyString(command_line()) &&
           VerifyOffset(verifier, VT_IMAGE_NAME) &&
           verifier.VerifyString(image_name()) &&
           verifier.EndTable();
  }
};

struct ProcessEventBuilder {
  typedef ProcessEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action(Sensor::ProcessAction action) {
    fbb_.AddElement<int8_t>(ProcessEvent::VT_ACTION, static_cast<int8_t>(action), 0);
  }
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ProcessEvent::VT_PID, pid, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ProcessEvent::VT_NAME, name);
  }
  void add_self_pid(int32_t self_pid) {
    fbb_.AddElement<int32_t>(ProcessEvent::VT_SELF_PID, self_pid, 0);
  }
  void add_command_line(::flatbuffers::Offset<::flatbuffers::String> command_line) {
    fbb_.AddOffset(ProcessEvent::VT_COMMAND_LINE, command_line);
  }
  void add_image_name(::flatbuffers::Offset<::flatbuffers::String> image_name) {
    fbb_.AddOffset(ProcessEvent::VT_IMAGE_NAME, image_name);
  }
  explicit ProcessEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessEvent> CreateProcessEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::ProcessAction action = Sensor::ProcessAction_ProcessStart,
    int32_t pid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t self_pid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> command_line = 0,
    ::flatbuffers::Offset<::flatbuffers::String> image_name = 0) {
  ProcessEventBuilder builder_(_fbb);
  builder_.add_image_name(image_name);
  builder_.add_command_line(command_line);
  builder_.add_self_pid(self_pid);
  builder_.add_name(name);
  builder_.add_pid(pid);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProcessEvent> CreateProcessEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::ProcessAction action = Sensor::ProcessAction_ProcessStart,
    int32_t pid = 0,
    const char *name = nullptr,
    int32_t self_pid = 0,
    const char *command_line = nullptr,
    const char *image_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto command_line__ = command_line ? _fbb.CreateString(command_line) : 0;
  auto image_name__ = image_name ? _fbb.CreateString(image_name) : 0;
  return Sensor::CreateProcessEvent(
      _fbb,
      action,
      pid,
      name__,
      self_pid,
      command_line__,
      image_name__);
}

struct RegistryEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegistryEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_KEY_PATH = 6,
    VT_VALUE_NAME = 8
  };
  Sensor::RegistryAction action() const {
    return static_cast<Sensor::RegistryAction>(GetField<int8_t>(VT_ACTION, 0));
  }
  const ::flatbuffers::String *key_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY_PATH);
  }
  const ::flatbuffers::String *value_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTION, 1) &&
           VerifyOffset(verifier, VT_KEY_PATH) &&
           verifier.VerifyString(key_path()) &&
           VerifyOffset(verifier, VT_VALUE_NAME) &&
           verifier.VerifyString(value_name()) &&
           verifier.EndTable();
  }
};

struct RegistryEventBuilder {
  typedef RegistryEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action(Sensor::RegistryAction action) {
    fbb_.AddElement<int8_t>(RegistryEvent::VT_ACTION, static_cast<int8_t>(action), 0);
  }
  void add_key_path(::flatbuffers::Offset<::flatbuffers::String> key_path) {
    fbb_.AddOffset(RegistryEvent::VT_KEY_PATH, key_path);
  }
  void add_value_name(::flatbuffers::Offset<::flatbuffers::String> value_name) {
    fbb_.AddOffset(RegistryEvent::VT_VALUE_NAME, value_name);
  }
  explicit RegistryEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegistryEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegistryEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegistryEvent> CreateRegistryEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::RegistryAction action = Sensor::RegistryAction_RegOpenKey,
    ::flatbuffers::Offset<::flatbuffers::String> key_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value_name = 0) {
  RegistryEventBuilder builder_(_fbb);
  builder_.add_value_name(value_name);
  builder_.add_key_path(key_path);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RegistryEvent> CreateRegistryEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Sensor::RegistryAction action = Sensor::RegistryAction_RegOpenKey,
    const char *key_path = nullptr,
    const char *value_name = nullptr) {
  auto key_path__ = key_path ? _fbb.CreateString(key_path) : 0;
  auto value_name__ = value_name ? _fbb.CreateString(value_name) : 0;
  return Sensor::CreateRegistryEvent(
      _fbb,
      action,
      key_path__,
      value_name__);
}

}  // namespace Sensor

#endif  // FLATBUFFERS_GENERATED_ALCA_SENSOR_H_
